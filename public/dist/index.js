/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./public/src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./public/src/canvas.js":
/*!******************************!*\
  !*** ./public/src/canvas.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var utils = __webpack_require__(/*! ./utils.js */ \"./public/src/utils.js\");\nvar consts = __webpack_require__(/*! ./consts.js */ \"./public/src/consts.js\");\n\n\nvar lineColor = consts.GRID_LINE_COLOR;\n\nvar boxBorderColor = consts.BOX_BORDER_COLOR;\n\n//Draw a single line in canvas context\nvar drawLine = function (ctx, p1, p2, color) {\n\tctx.beginPath();\n\tctx.moveTo(p1.x, p1.y);\n\tctx.lineTo(p2.x, p2.y);\n\n\tctx.lineWidth = 1;\n\tctx.strokeStyle = color;\n\n\tctx.stroke();\n\tctx.closePath();\n};\n\n\n//Draw game grids\nvar drawGrids = function (el, gridSize, colCount, rowCount, color1, color2) {\n\n\tvar ctx = el.getContext('2d');\n\tvar width = el.width;\n\tvar height = el.height;\n\n\tctx.rect(0, 0, width, height);\n\n\tvar grd = ctx.createLinearGradient(0, 0, 0, height);\n\tgrd.addColorStop(0, color1);\n\tgrd.addColorStop(1, color2);\n\tctx.fillStyle = grd;\n\tctx.fill();\n\n\n\tfor (var i = 1; i < colCount; i++) {\n\t\tvar x = gridSize * i + 0.5;\n\t\tdrawLine(ctx, {\n\t\t\tx: x,\n\t\t\ty: 0\n\t\t}, {\n\t\t\tx: x,\n\t\t\ty: height\n\t\t}, lineColor);\n\t};\n\tfor (var i = 1; i < rowCount; i++) {\n\t\tvar y = gridSize * i + 0.5;\n\t\tdrawLine(ctx, {\n\t\t\tx: 0,\n\t\t\ty: y\n\t\t}, {\n\t\t\tx: width,\n\t\t\ty: y\n\t\t}, lineColor);\n\t};\n};\n\n//Draw box of shape (shape is the composition of boxes)\nvar drawBox = function (ctx, color, x, y, gridSize, isGhost = false) {\n\tif (y < 0) {\n\t\treturn;\n\t}\n\n\n\tctx.beginPath();\n\tctx.rect(x, y, gridSize, gridSize);\n\tctx.fillStyle = color;\n\n\tif (isGhost) {\n\t\tctx.strokeStyle = consts.INACTIVE; //ghost piece color\n\t\tctx.lineWidth = 0;//used to be 3\n\t} else {\n\t\tctx.fill();\n\t\tctx.strokeStyle = boxBorderColor;\n\t\tctx.lineWidth = 1;\n\t}\n\n\tctx.stroke();\n\tctx.closePath();\n}\n\n/*\n\tCanvas main object, use to draw all games data.\n*/\nvar tetrisCanvas = {\n\n\tinit: function (scene, preview) {\n\t\tthis.scene = scene;\n\t\tthis.preview = preview;\n\t\tthis.sceneContext = scene.getContext('2d');\n\t\tthis.previewContext = preview.getContext('2d');\n\t\tthis.gridSize = scene.width / consts.COLUMN_COUNT;\n\n\t\tthis.previewGridSize = preview.width / consts.PREVIEW_COUNT;\n\n\t\tthis.drawScene();\n\n\t},\n\n\t//Clear game canvas\n\tclearScene: function () {\n\t\tthis.sceneContext.clearRect(0, 0, this.scene.width, this.scene.height);\n\t},\n\t//Clear preview canvas\n\tclearPreview: function () {\n\t\tthis.previewContext.clearRect(0, 0, this.preview.width, this.preview.height);\n\t},\n\t//Draw game scene, grids\n\tdrawScene: function () {\n\t\tthis.clearScene();\n\t\tdrawGrids(this.scene, this.gridSize,\n\t\t\tconsts.COLUMN_COUNT, consts.ROW_COUNT,\n\t\t\tconsts.SCENE_BG_START, consts.SCENE_BG_END);\n\t},\n\t//Draw game data\n\tdrawMatrix: function (matrix, isTurn = true) {\n\t\tfor (var i = 0; i < matrix.length; i++) {\n\t\t\tvar row = matrix[i];\n\t\t\tfor (var j = 0; j < row.length; j++) {\n\t\t\t\tif (row[j] !== 0) {\n\t\t\t\t\tdrawBox(this.sceneContext, (isTurn ? row[j] : consts.INACTIVE), j * this.gridSize, i * this.gridSize, this.gridSize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t//Draw preview data\n\tdrawPreview: function () {\n\t\tdrawGrids(this.preview, this.previewGridSize,\n\t\t\tconsts.PREVIEW_COUNT, consts.PREVIEW_COUNT,\n\t\t\tconsts.PREVIEW_BG, consts.PREVIEW_BG);\n\t},\n\t//Draw acitve shape in game\n\tdrawShape: function (shape, isMyTurn, isGhost= false){\n\t\tif (!shape) {\n\t\t\treturn;\n\t\t}\n\t\tvar matrix = shape.matrix();\n\t\tvar gsize = this.gridSize;\n\t\tfor (var i = 0; i < matrix.length; i++) {\n\t\t\tfor (var j = 0; j < matrix[i].length; j++) {\n\t\t\t\tvar value = matrix[i][j];\n\t\t\t\tif (value === 1) {\n\t\t\t\t\tvar x = gsize * (shape.x + j);\n\t\t\t\t\tvar y = gsize * (shape.y + i);\n\t\t\t\t\tdrawBox(this.sceneContext, (isMyTurn ? shape.color : consts.INACTIVE) , x, y, gsize, isGhost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t//Draw preview shape in preview canvas\n\tdrawPreviewShape: function (shape, isMyTurn) {\n\t\tif (!shape) {\n\t\t\treturn;\n\t\t}\n\t\tthis.clearPreview();\n\t\tvar matrix = shape.matrix();\n\t\tvar gsize = this.previewGridSize;\n\t\tvar startX = (this.preview.width - gsize * shape.getColumnCount()) / 2;\n\t\tvar startY = (this.preview.height - gsize * shape.getRowCount()) / 2;\n\t\tfor (var i = 0; i < matrix.length; i++) {\n\t\t\tfor (var j = 0; j < matrix[i].length; j++) {\n\t\t\t\tvar value = matrix[i][j];\n\t\t\t\tif (value === 1) {\n\t\t\t\t\tvar x = startX + gsize * j;\n\t\t\t\t\tvar y = startY + gsize * i;\n\t\t\t\t\tdrawBox(this.previewContext, shape.color , x, y, gsize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n};\n\nmodule.exports = tetrisCanvas;\n\n//# sourceURL=webpack:///./public/src/canvas.js?");

/***/ }),

/***/ "./public/src/consts.js":
/*!******************************!*\
  !*** ./public/src/consts.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//colors for shapes\nvar colors = ['#00af9d', '#ffb652', '#cd66cc', '#66bc29', '#0096db', '#3a7dda', '#ffe100', '#46ffff', '#ff8200', ];\n\n//inactive player color\nvar inactive = '#C0C0C0';\n\n//sidebar width\nvar sideWidth = 200;\n\n//scene column count\nvar columnCount = 10;\n\n//scene row count;\nvar rowCount = 20;\n\n//previewCount\nvar previewCount = 6;\n\n//scene gradient start color \nvar sceneBgStart = '#8e9ba6';\n\n//scene gradient end color \nvar sceneBgEnd = '#5c6975';\n\n//preview background color\nvar previewBg = '#2f2f2f';\n\n//grid line color\nvar gridLineColor = 'rgba(255,255,255,0.2)';\n\n//box border color\nvar boxBorderColor = 'rgba(255,255,255,0.5)';\n\n// Default Shape color\nvar DEFAULT_COLOR = 8;\n\n// Level update interval (milliseconds)\nvar levelInterval = 120 * 1000;\n\n//VARIABLES YOU MIGHT LIKE TO CHANGE\n\n//waitTime (seconds)\nvar waitTime = 0.8;\n\n//number of turns per player\nvar numplays = 1;\n\n//number of players allowed in a game\nvar numplayers = 2;\n\n//use turn calculator (true or false. true to use, false otherwise)\nvar useTurnCalc = false;\n\n// Turn on/off ghost shape\nvar useGhostShape = false;\n\n// Game speed (milliseconds)\nvar defaultInterval = 600;\nvar defaultGhostInterval = 450;\n\n// Random Distribution for blocks  (true or false. true to use, false otherwise)\nvar useRandomNumDist = false; \n\n// List Distribution for blocks (true or false. true to use, false otherwise) \nvar useListNumDist = false;\n\n// Random Distribution with Constraints for blocks (true or false. true to use, false otherwise)\nvar useRandomConstraint = true; \n\nvar exports = module.exports = {};\n\nexports.DEFAULT_COLOR = DEFAULT_COLOR;\n\nexports.COLORS = colors;\n\nexports.SIDE_WIDTH = sideWidth;\n\nexports.ROW_COUNT = rowCount;\n\nexports.COLUMN_COUNT = columnCount;\n\nexports.SCENE_BG_START = sceneBgStart;\n\nexports.SCENE_BG_END = sceneBgEnd;\n\nexports.PREVIEW_BG = previewBg;\n\nexports.PREVIEW_COUNT = previewCount;\n\nexports.GRID_LINE_COLOR = gridLineColor;\n\nexports.BOX_BORDER_COLOR = boxBorderColor;\n\nexports.DEFAULT_INTERVAL = defaultInterval;\n\nexports.DEFAULT_GHOST_INTERVAL = defaultGhostInterval;\n\nexports.LEVEL_INTERVAL = levelInterval;\n\nexports.WAIT_TIME = waitTime;\n\nexports.NUM_PLAYS = numplays;\n\nexports.NUM_PLAYERS = numplayers;\n\nexports.USE_TURN_CALC = useTurnCalc;\n\nexports.USE_GHOST_SHAPE = useGhostShape;\n\nexports.USE_RANDOM_CALC = useRandomNumDist;\n\nexports.USE_LIST_CALC = useListNumDist;\n\nexports.USE_CONSTRAINT_CALC = useRandomConstraint;\n\nexports.INACTIVE = inactive;\n\n//# sourceURL=webpack:///./public/src/consts.js?");

/***/ }),

/***/ "./public/src/main.js":
/*!****************************!*\
  !*** ./public/src/main.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var utils = __webpack_require__(/*! ./utils.js */ \"./public/src/utils.js\");\nvar consts = __webpack_require__(/*! ./consts.js */ \"./public/src/consts.js\");\nvar socketFunc = __webpack_require__(/*! ./socket.js */ \"./public/src/socket.js\");\nvar shapes = __webpack_require__(/*! ./shapes.js */ \"./public/src/shapes.js\");\nvar views = __webpack_require__(/*! ./views.js */ \"./public/src/views.js\");\nvar canvas = __webpack_require__(/*! ./canvas.js */ \"./public/src/canvas.js\");\n\n/**\n\tInit game matrix\n*/\nvar initMatrix = function (rowCount, columnCount) {\n\tvar result = [];\n\tfor (var i = 0; i < rowCount; i++) {\n\t\tvar row = [];\n\t\tresult.push(row);\n\t\tfor (var j = 0; j < columnCount; j++) {\n\t\t\trow.push(0);\n\t\t}\n\t}\n\treturn result;\n};\n\n/**\n  Clear game matrix\n*/\nvar clearMatrix = function (matrix) {\n\tfor (var i = 0; i < matrix.length; i++) {\n\t\tfor (var j = 0; j < matrix[i].length; j++) {\n\t\t\tmatrix[i][j] = 0;\n\t\t}\n\t}\n};\n\n/**\n\tCheck all full rows in game matrix\n\treturn rows number array. eg: [18,19];\n*/\nvar checkFullRows = function (matrix) {\n\tvar rowNumbers = [];\n\tfor (var i = 0; i < matrix.length; i++) {\n\t\tvar row = matrix[i];\n\t\tvar full = true;\n\t\tfor (var j = 0; j < row.length; j++) {\n\t\t\tfull = full && row[j] !== 0;\n\t\t}\n\t\tif (full) {\n\t\t\trowNumbers.push(i);\n\t\t}\n\t}\n\treturn rowNumbers;\n};\n\n/**\n\tRemove one row from game matrix. \n\tcopy each previous row data to  next row  which row number less than row;\n*/\nvar removeOneRow = function (matrix, row) {\n\tvar colCount = matrix[0].length;\n\tfor (var i = row; i >= 0; i--) {\n\t\tfor (var j = 0; j < colCount; j++) {\n\t\t\tif (i > 0) {\n\t\t\t\tmatrix[i][j] = matrix[i - 1][j];\n\t\t\t} else {\n\t\t\t\tmatrix[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n};\n/**\n\tRemove rows from game matrix by row numbers.\n*/\nvar removeRows = function (matrix, rows) {\n\tfor (var i in rows) {\n\t\tremoveOneRow(matrix, rows[i]);\n\t}\n};\n\n/**\n\tCheck game data to determin wether the  game is over\n*/\nvar checkGameOver = function (matrix) {\n\tvar firstRow = matrix[0];\n\tfor (var i = 0; i < firstRow.length; i++) {\n\t\tif (firstRow[i] !== 0) {\n\t\t\treturn true;\n\t\t};\n\t}\n\treturn false;\n};\n\n\n/**\n\tCalculate  the extra rewards add to the score\n*/\nvar calcRewards = function (rows) {\n\t// if (rows && rows.length > 1) {\n\t// \treturn Math.pow(2, rows.length - 1) * 100;\n\t// }\n\treturn 0;\n};\n\n/**\n\tCalculate game score\n*/\nvar calcScore = function (rows) {\n\tif (rows && rows.length) {\n\t\tswitch (rows.length) {\n\t\t\tcase 1:\n\t\t\t\treturn 40;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\treturn 100;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\treturn 300;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\treturn 1200;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n};\n\n/**\t \n\tCheck if the inactive and active pieceves are the same \n*/\nvar checkSame = function (active, inactive) {\n\treturn (JSON.stringify(active) === JSON.stringify(inactive));\n}\n\n\n/**\n\tCalculate time interval by level, the higher the level,the faster shape moves\n*/\n// var calcIntervalByLevel = function (level) {\n// \treturn consts.DEFAULT_INTERVAL; //In order to return default interval - (level - 1) * 60;\n// };\n\n\n// Default max scene size\nvar defaults = {\n\tmaxHeight: 500,\n\tmaxWidth: 900\n};\n\n/**\n\tTetris main object definition\n*/\nfunction Tetris(id, socket, options) {\n\t/** Configuration fields */\n\tthis.id = id; // container Id (from index.html)\n\tthis.MAX_TURNS = 200; // game end condition (turnCount == MAX_TURNS)\n\tthis.config = utils.extend(options, defaults); // game config for accessing maxWidth and maxHeight\n\t/** per-game based fields */\n\tthis.gameId = options.gameId || \"\"; // game id assigned in the beginning\n\tthis.playerName = options.playerName; // player name\n\tviews.setPlayer(this.playerName);\n\tthis.socket = socket; // socket object\n\t/** per-turn based fields */\n\tthis.currentTurn = this.playerName; // name of the player playing current turn\n\tthis.turnCount = 0; // number of times turn changed\n\tthis.nextPlayerId  = 0; // the next player's socketId \n\t/** per-block based fields */\n\tthis.playCount = 0; // number of times either player played a block\n\tthis.suggestionTaken = 0; // number of times current player has taken the suggestion made by the inactive player during this turn\n\tthis.playersTally = null; // object that records players' game playing (key-inputs used, etc)\n\tthis.interval = consts.DEFAULT_INTERVAL; // time interval used to drop the active shape by one row \n\tthis.ghostShapeInterval = consts.DEFAULT_GHOST_INTERVAL; // time interval used to drop the ghost shape by one row \n\tviews.init(this.id, this.config.maxWidth, this.config.maxHeight);\n\tcanvas.init(views.scene, views.preview);\n\tthis.matrix = initMatrix(consts.ROW_COUNT, consts.COLUMN_COUNT);\n\t/** etc */\n\tthis.resetCount = 0; // number of times the matrix gets cleaned out bc a block touched the top of the matrix\n\tthis.init();\n\tthis.randVar = 0;\n}\n\nTetris.prototype = {\n\n\tinit: function (options) {\n\t\tconsole.log(\"in init\");\n\t\t// Ask to join the game\n\t\t// how to check whether the player is a previousy played person or not. \n\t\tthis.socket.emit(\"checkPlayer\", {\n\t\t\tplayerName: this.playerName\n\t\t});\n\n\t\tthis.socket.on(\"confirmPlayer\", (data) => {\n\n\t\t\tif (!data.duplicate) {\n\t\t\t\tconsole.log(\"PLAYER JOINED GAME\", this.playerName)\n\n\t\t\t\t// how does this go along at this point \n\t\t\t\tthis.socket.emit(\"join_game\", {\n\t\t\t\t\tsocketId: socket.id,\n\t\t\t\t\tgameId: this.gameId,\n\t\t\t\t\tplayerName: this.playerName\n\t\t\t\t});\n\n\t\t\t} else{\n\t\t\t\tviews.setDupPlayerMessage(data.duplicate);\n\t\t\t\tconsole.log(\" DUPLICATED DATA \", data.duplicate)\n\t\t\t}\n\t\t})\n\n\n\t\t// Receive response for its join-room request\n\t\tthis.socket.on(\"join_room_ack\", (data) => {\n\t\t\tconsole.log(\"JOINED ROOM ACK\", data);\n\t\t\tconsole.log(\"join_room_ack :: \" + data.joinedGame + \" :: gameId ::\" + data.gameId);\n\t\t\tthis.gameId = data.gameId;\n\t\t\tthis.playersTally = data.playersTally;\n\t\t\tthis.shapeList = [];\n\t\t\tthis.timeList = [];\n\t\t\tthis.is_AI = 0;\n\t\t\tthis.nextPlayerId = data.currentSocketId;\n\t\t\tthis.randVar = data.randVar;\n\n\n\t\t\tconsole.log(\"this.nextplayerid join\", this.nextPlayerId);\n\n\t\t\tif (!data.joinedGame) {\n\t\t\t\tviews.setPairingMessage(true);\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tviews.setEndPairingMessage(true); \n\n\t\t\t\t\t// end pairing message \n\t\t\t\t\tthis.socket.emit(\"end_pair\", {\n\t\t\t\t\t\tend_pair: true\n\t\t\t\t\t})\n\n\t\t\t\t}, 600000 );\n\t\t\t} else {\n\t\t\t\tviews.setPairingMessage(false);\n\n\t\t\t\tthis.is_AI = data.is_AI;\n\n\t\t\t\tif (this.is_AI == 0) {\n\t\t\t\t\tviews.setAIPairingImage(false); \n\t\t\t\t} else {\n\t\t\t\t\tviews.setAIPairingImage(true); \n\t\t\t\t}\n\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tviews.hideModal();\n\t\t\t\t\tviews.showTetris();\n\t\t\t\t}, 10000); //10000 change\n\n\t\t\t\t// activate the button \n\t\t\t\tviews.activateQuitButton();\n\t\t\t\t// partner name and current player name\n\t\t\t\tif (data.players[0].playerName == this.playerName) {\n\t\t\t\t\tthis.partnerName = data.players[1].playerName;\n\t\t\t\t} else {\n\t\t\t\t\tthis.partnerName = data.players[0].playerName;\n\t\t\t\t}\n\t\t\t\t//remove if you want IDs to show  \n\n\t\t\t\t//views.setQuitGamePlayer(this.playerName, this.partnerName); \n\t\t\t\t//views.setGameOverPlayer(this.playerName, this.partnerName);\n\t\t\t\tviews.setQualtLink(this.playerName, this.partnerName, this.is_AI,this.randVar);\n\n\t\t\t}\n\n\t\t\tif (data.currentTurn && data.joinedGame) {\n\n\t\t\t\tthis.currentTurn = data.currentTurn;\n\t\t\t\t// pair not matched in 5 minutes\n\t\t\t\tif (this.isMyTurn()) {\n\t\t\t\t\tviews.setNotification(1,this.is_AI);//your turn\n\t\t\t\t\tthis._fireShape();\n\t\t\t\t} else {\n\t\t\t\t\tviews.setNotification(0,this.is_AI);//other player's turn\n\t\t\t\t}\n\n\t\t\t\tviews.setTurn(this.currentTurn,this.playerName);\n\n\t\t\t\tthis.reset();\n\t\t\t\tthis._initEvents();\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tconsole.log(\"Game Resume\");\n\t\t\t\t\tthis.turnStart = new Date().getTime();\n\t\t\t\t\tthis.roundStart = this.turnStart;\n\n\t\t\t\t\tif (this.isMyTurn()) {\n\t\t\t\t\t\tthis.running = true;\n\t\t\t\t\t\tthis._refresh();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.running = false;\n\t\t\t\t\t}\n\t\t\t\t}, consts.WAIT_TIME * 1000); \n\t\t\t}\n\t\t})\n\n\t\t//GAME STATE\n\t\tthis.socket.on(\"state\", (data) => {\n\t\t\tthis._setStatePayload(data);\n\t\t\tthis._draw();\n\t\t});\n\n\t\t// Emitted by the inactive player after moving its ghost piece\n\t\tthis.socket.on('ghostShapeMoved', (data) => {\n\t\t\tthis._moveGhostShape(data);\n\t\t\tthis._draw();\n\t\t});\n\n\t\t// Players listen to see if anyone presses the quit button\n\t\tthis.socket.on('quit game', (data) => {\n\t\t\tthis.gameOver(false);\n\t\t\tthis._draw();\n\t\t});\n\n\t\t//TURN CHANGED\n\t\tthis.socket.on(\"turn_change\", (data) => {\n\t\t\tconsole.log(\"Game Freeze\");\n\t\n\t\t\tthis.shapeList = [];\n\t\t\tthis.timeList = [];\n\t\t\t// this.pause();\n\t\t\tconsole.log(\"turn_change :: \" + this.currentTurn);\n\t\t\tthis.playCount = data.playCount;\n\t\t\tthis.turnCount = data.turnCount;\n\t\t\tthis.nextPlayerId = data.nextPlayerId;\n\t\t\tviews.setTurnCount(this.turnCount);\n\t\t\t\n\t\t\t// Ghost movements are updated to database whenever a turn changes\n\t\t\tif (!this.isMyTurn()) {\n\t\t\tthis.socketEmit(\"record_ghost_movement\", {\n\t\t\t\tgameId: this.gameId,\n\t\t\t\tplayersTally: this.playersTally,\n\t\t\t\tghostPlayer: this.playerName,\n\t\t\t\tturnCount: this.turnCount,\n\t\t\t\tplayCount: this.playCount\n\t\t\t\t})\n\t\t\t} \n\n\t\t\tthis.playersTally = data.playersTally;\n\n\t\t\t//changing current players last score to zero\n\t\t\tconsole.log(\"play Count in the game\", this.playCount);\n\n\t\t\tconsole.log(\"TURN:::::::::playerName :: \" + this.playerName + \", playCount :: \" + this.playCount + \", currentTurn ::\" + this.currentTurn);\n\n\t\t\tviews.setImageNotification(this.is_AI);\n\t\t\tviews.setDistributer(this.is_AI);\n\t\t\tviews.setTurn(0,0);\n\n\n\t\t\tsetTimeout(() => {\n\t\t\t\tconsole.log(\"Game Resume\");\n\t\t\t\tthis.turnStart = new Date().getTime();\n\t\t\t\tthis.currentTurn = data.currentTurn;\n\t\t\t\tviews.setTurn(this.currentTurn,this.playerName);\n\n\t\t\t\tif (this.isMyTurn()) {\n\t\t\t\t\tthis.running = true;\n\t\t\t\t\tthis._refresh();\n\t\t\t\t\tviews.setNotification(\"YOUR TURN\"); \n\t\t\t\t\t} else {\n\t\t\t\t\tthis.running = false;\n\t\t\t\t\tviews.setNotification(\"OTHER PLAYER'S TURN\"); \n\t\t\t\t}\n\t\t\t}, consts.WAIT_TIME * 3000);\n\n\t\t\tthis.suggestionTaken = 0;\n\n\t\t})\n\t\t//TURN STATE\n\t\tthis.socket.on(\"turn_state\", (data) => {\n\t\t\tconsole.log(data)\n\t\t\tthis.currentSuggestionTaken = 0 \n\t\t\tthis.playersTally = data.playersTally;\n\t\t\tthis.playCount = data.playCount;\n\t\t\tconsole.log(\"TURN_STATE:::::::::playCount :: \" + this.playCount);\n\t\t})\n\t\t//DISOCNNECT ACK\n\t\tthis.socket.on(\"disconnect_ack\", (data) => {\n\t\t\tconsole.log(data)\n\t\t\tif (data.disconnect) {\n\t\t\t\tviews.setNotification(\"Other player left please start a new game\");\n\t\t\t\tthis.pause();\n\t\t\t}\n\t\t});\n\t},\n\n\t//Reset game\n\treset: function () {\n\t\tconsole.log(\"RESET\");\n\t\tthis.running = false;\n\t\tthis.isGameOver = false;\n\t\tthis.level = 1;\n\t\tthis.score = 0;\n\t\tthis.startTime = new Date().getTime();\n\t\tthis.currentTime = this.startTime;\n\t\tthis.individualScore = 0;\n\t\t//this.prevTime = this.startTime;\n\t\t//this.levelTime = this.startTime;\n\t\tclearMatrix(this.matrix);\n\t\t//setLevel(this.level);\n\t\tviews.setScore(this.score);\n\t\tviews.setGameOver(this.isGameOver);\n\n\t\tthis._draw();\n\t},\n\n\t//Start game\n\tstart: function () {\n\t\tconsole.log(\"in start\");\n\t\tthis.running = true;\n\t\twindow.requestAnimationFrame(utils.proxy(this._refresh, this));\n\t\tif (this.isMyTurn()) {\n\t\t\tthis.socketEmit(this._getStatePayload());\n\t\t}\n\t},\n\n\t//Pause game\n\tpause: function () {\n\t\tthis.running = false;\n\t\tthis.currentTime = new Date().getTime();\n\t\tthis.prevTime = this.currentTime;\n\t\tthis.prevGhostUpdateTime = this.currentTime;\n\t\tif (this.isMyTurn()) {\n\t\t\tthis.socketEmit(\"state\", this._getStatePayload());\n\t\t}\n\t},\n\n\t// game finishes from a player pressing the quit button\n\t// NOTE: this is not the routine that gets called when MAX_TURN has reached\n\tgameOver: function (notifyOtherPlayers) {\n\t\tthis.running = false; \n\t\tthis.isGameOver = true; \n\t\tviews.setQuitFinalScore(this.score);\n\t \tviews.setQuitGame(this.isGameOver);\n\t \t// notify other players that the game is over.\n\t\tif (notifyOtherPlayers) {\n\t\t\tthis.socketEmit(\"quit game\", this._getStatePayload())\n\t\t}\n\t},\n\n\t//isMyTurn =>\n\tisMyTurn: function () {\n\t\treturn (this.playerName === this.currentTurn);\n\t},\n\n\t//state Payload\n\t_getStatePayload: function () {\n\t\tlet currState = {\n\t\t\tgameId: this.gameId,\n\t\t\tplayerName: this.playerName,\n\t\t\tcurrentTurn: this.currentTurn,\n\t\t\tmatrix: this.matrix,\n\t\t\trunning: this.running,\n\t\t\tisGameOver: this.isGameOver,\n\t\t\tshape: this.shape,\n\t\t\tpreparedShape: this.preparedShape,\n\t\t\t//level: this.level,\n\t\t\tinterval: this.interval,\n\t\t\tghostShapeInterval: this.ghostShapeInterval,\n\t\t\tscore: this.score,\n\t\t\tstartTime: this.startTime,\n\t\t\tresetCount: this.resetCount\n\t\t\t//levelTime: this.levelTime\n\t\t}\n\t\tif (consts.USE_GHOST_SHAPE) currState.ghostShape = this.ghostShape\n\t\treturn currState;\n\t},\n\t// set state payload\n\t_setStatePayload: function (data) {\n\t\tconsole.log(\"Inside Set State\");\n\n\t\tthis.matrix = data.matrix || this.matrix;\n\t\tif (this.running != data.running) {\n\t\t\tthis.running = data.running;\n\t\t\tif (this.running) {\n\t\t\t\tthis.start();\n\t\t\t}\n\t\t}\n\n\t\tthis.isGameOver = data.isGameOver || this.isGameOver;\n\t\t//Shape\n\t\tif (this.shape) this.shape.updateShape(data.shape);\n\t\telse this.shape = shapes.generateShape(data.shape);\n\n\t\t//prepared Shape\n\t\tif (this.preparedShape) this.preparedShape.updateShape(data.preparedShape);\n\t\telse this.preparedShape = shapes.generateShape(data.preparedShape); //TODO: This else branch is never called. \n\t\tcanvas.drawPreviewShape(this.preparedShape);\n\n\t\t//first ghost\n\t\tif (!this.ghostShape) this.ghostShape = shapes.generateShape(data.shape);\n\n\t\t//change level in view on level change\n\t\t// if (this.level != data.level) {\n\t\t// \tthis.level = data.level;\n\t\t// \tviews.setLevel(this.level);\n\t\t// }\n\n\t\t// this.interval = data.interval || this.interval;\n\t\tif (this.score != data.score) {\n\t\t\tthis.score = data.score;\n\t\t\tviews.setScore(this.score);\n\t\t}\n\t\tthis.score = data.score || this.score;\n\t\n\t\tthis.resetCount = data.resetCount || this.resetCount;\n\n\t\t//this.levelTime = data.levelTime || this.levelTime;\n\t},\n\n\t// The active player calls this when inactive player has moved his ghost piece\n\t_moveGhostShape: function (data) {\n\t\tconsole.log(\"in moveGhostShape\");\n\t\tthis.ghostShape.updateShape(data.ghostShape);\n\t},\n\n\t//socketEmit()\n\tsocketEmit: function (event, message) {\n\t\tthis.socket.emit(event, message);\n\t},\n\n\n\t// All key event handlers\n\t_keydownHandler: function (e) {\n\t\tvar matrix = this.matrix;\n\t\tvar myTurn = this.isMyTurn();\n\t\tif (!e) {\n\t\t\tvar e = window.event;\n\t\t}\n\t\tif (this.isGameOver || !this.shape || document.activeElement.id === \"textInput\") {\n\t\t\treturn;\n\t\t}\n\n\t\t// active player key input control\n\t\tif (myTurn) {\n\t\t\tswitch (e.keyCode) {\n\t\t\t\tcase 37: {\n\t\t\t\t\tif (!this.running) return;\n\t\t\t\t\tif (this.shape.canLeft(matrix)) {\n\t\t\t\t\t\tthis.playersTally[this.socket.id].buttons.left += 1; //add to the left tally\n\t\t\t\t\t}\n\t\t\t\t\tthis.shape.goLeft(matrix);\n\t\t\t\t\tthis._draw();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 39: {\n\t\t\t\tif (!this.running) return;\n\t\t\t\tif (this.shape.canRight(matrix)) {\n\t\t\t\t\tthis.playersTally[this.socket.id].buttons.right += 1; //add to the right tally\n\t\t\t\t}\n\t\t\t\tthis.shape.goRight(matrix);\n\t\t\t\tthis._draw();\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 38: {\n\t\t\t\tif (!this.running) return;\n\t\t\t\tthis.shape.rotate(matrix);\n\t\t\t\tthis.playersTally[this.socket.id].buttons.rotate += 1; //add to the rotate tally\n\t\t\t\tthis._draw();\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 40: {\n\t\t\t\tif (!this.running) return;\n\t\t\t\tif (this.shape.canDown(matrix)) {\n\t\t\t\t\tthis.playersTally[this.socket.id].buttons.down += 1; //add to the down tally\n\t\t\t\t\tif (this.isMyTurn) {\n\t\t\t\t\t\tthis.score += 1;\n\t\t\t\t\t\tthis.individualScore +=1; \n\n\t\t\t\t\t\tconsole.log(\"soft drop score = \" + this.score);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.shape.goDownBut(matrix);\n\t\t\t\tthis._draw();\n\t\t\t}\n\t\t\tbreak;\n\t\t\t//pause - remove 'p' functionality\n\t\t\t// case 80: {\n\t\t\t// \tif (this.running) {\n\t\t\t// \t\tthis.pause();\n\t\t\t// \t} else {\n\t\t\t// \t\tthis.start();\n\t\t\t// \t}\n\t\t\t// \tthis._draw();\n\t\t\t// }\n\t\t\t// break;\n\t\t\tcase 32: {\n\t\t\t\tif (!this.running) return;\n\t\t\t\tif (this.shape.canDown(matrix)) {\n\t\t\t\t\tthis.playersTally[this.socket.id].buttons.bottom += 1;\n\t\t\t\t} //add to the bottom tally\n\n\t\t\t\tmatrixBottom = this.shape.goBottom(matrix);\n\t\t\t\tthis.score += matrixBottom; \n\t\t\t\tthis.individualScore += matrixBottom;\n\t\t\t\tviews.setScore(this.score);\n\n\t\t\t\tconsole.log(\"drop score matrixBottom = \" + matrixBottom);\n\t\t\t\tconsole.log(\"drop score = \" + this.score);\n\t\t\t\tthis._update();\n\t\t\t}\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// key event handlers for the inactive player (control over the ghost piece is allowed)\n\t\telse {\n\t\t\tif (consts.USE_GHOST_SHAPE) {\n\t\t\t\tswitch (e.keyCode) {\n\t\t\t\t\tcase 37: {\n\t\t\t\t\t\tif (!this.running) return;\n\t\t\t\t\t\tif (this.ghostShape.canLeft(matrix)) {\n\t\t\t\t\t\t\tthis.playersTally[this.socket.id].ghostButtons.left += 1; //add to the left tally\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.ghostShape.goLeft(matrix);\n\t\t\t\t\t\tthis._draw();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 39: {\n\t\t\t\t\tif (!this.running) return;\n\t\t\t\t\tif (this.ghostShape.canRight(matrix)) {\n\t\t\t\t\t\t\tthis.playersTally[this.socket.id].ghostButtons.right += 1; //add to the right tally\n\t\t\t\t\t\t}\n\t\t\t\t\tthis.ghostShape.goRight(matrix);\n\t\t\t\t\tthis._draw();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase 38: {\n\t\t\t\t\tif (!this.running) return;\n\t\t\t\t\tthis.playersTally[this.socket.id].ghostButtons.rotate += 1; //add to the rotate tally\t\n\t\t\t\t\tthis.ghostShape.rotate(matrix);\n\t\t\t\t\tthis._draw();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase 40: {\n\t\t\t\t\tif (!this.running) return;\n\t\t\t\t\tif (this.ghostShape.canDown(matrix)) {\n\t\t\t\t\t\t\tthis.playersTally[this.socket.id].ghostButtons.down += 1; //add to the dowm tally\n\t\t\t\t\t\t}\n\t\t\t\t\tthis.ghostShape.goDownBut(matrix);\n\t\t\t\t\tthis._draw();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase 32: {\n\t\t\t\t\tif (!this.running) return;\n\t\t\t\t\tif (this.ghostShape.canDown(matrix)) {\n\t\t\t\t\t\t\tthis.playersTally[this.socket.id].ghostButtons.bottom += 1; \n\t\t\t\t\t\t}\n\t\t\t\t\tthis.ghostShape.goBottom(matrix);\n\t\t\t\t\tthis._update();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.isMyTurn()) {\n\t\t\tthis.socketEmit(\"state\", this._getStatePayload());\n\t\t} else {\n\t\t\tif (consts.USE_GHOST_SHAPE) {\n\t\t\t\tthis.socketEmit(\"ghostShapeMoved\", this._getStatePayload());\n\t\t\t\t// this.socketEmit(\"state\", this._getStatePayload());\n\t\t\t}\n\t\t}\n\n\t},\n\n\t// Restart game\n\t_restartHandler: function () {\n\t\tthis.reset();\n\t\tthis.start();\n\t},\n\t// Bind game events\n\t_initEvents: function () {\n\t\twindow.addEventListener('keydown', utils.proxy(this._keydownHandler, this), false);\n\t\t//views.btnRestart.addEventListener('click', utils.proxy(this._restartHandler, this), false);\n\t},\n\n\n\t// Fire a new random shape\n\t_fireShape: function () {\n\t\tconsole.log(\"in fireshape\");\n\t\tthis.shape = this.preparedShape || shapes.generateShape(); //changed\n\t\tif (consts.USE_GHOST_SHAPE) {\n\t\t\tthis.ghostShape = shapes.generateShape(this.shape); //ghostShape is always equal to our main piece;\n\t\t}\n\t\tif (this.isMyTurn()) {\n\t\t\tthis.preparedShape = shapes.generateShape(); //changed\n\t\t}\n\t\tthis._draw();\n\t\tthis.socketEmit(\"state\", this._getStatePayload());\n\t\tthis.socketEmit(\"ghostShapeMoved\", this._getStatePayload());\n\t\tcanvas.drawPreviewShape(this.preparedShape);\n\t},\n\n\t// Draw game data\n\t_draw: function () {\n\t\tcanvas.drawScene();\n\t\tcanvas.drawShape(this.shape, this.isMyTurn(), isGhost = false);\n\n\t\t// update GhostShape if shapes not equal\n\t\tif (this.ghostShape!== undefined && this.ghostShape.flag !== this.shape.flag) {\n\t\t\tconsole.log(\"Ghost Shape and Main Shape not Equal\");\n\t\t\tthis.ghostShape = shapes.generateShape(this.shape);\n\t\t}\n\n\t\tcanvas.drawShape(this.ghostShape, this.isMyTurn(), isGhost = true); // drawShape just returns when ghost shape feature is off.\n\t\tcanvas.drawMatrix(this.matrix, this.isMyTurn());\n\t},\n\t// Refresh game canvas\n\t_refresh: function () {\n\t\tif (!this.running) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.currentTime = new Date().getTime();\n\t\t//\tconsole.log(\"refresh :: \" + (this.currentTime - this.prevTime > this.interval));\n\t\tif (this.currentTime - this.prevTime > this.interval) {\n\t\t\tthis._update();\n\t\t\tthis.prevTime = this.currentTime;\n\t\t\t//this._checkLevel();\n\t\t}\n\n\t\tif (this.currentTime - this.prevGhostUpdateTime > this.ghostShapeInterval) {\n\t\t\tthis._updateGhostShape();\n\t\t\tthis.prevGhostUpdateTime = this.currentTime;\n\t\t}\n\n\t\tif (!this.isGameOver) {\n\t\t\twindow.requestAnimationFrame(utils.proxy(this._refresh, this));\n\t\t}\n\t},\n\n\t// update ghost shape\n\t_updateGhostShape: function () {\n\t\tif (!this.isMyTurn() && consts.USE_GHOST_SHAPE && this.ghostShape.canDown(this.matrix)) {\n\t\t\tthis.ghostShape.goDown(this.matrix);\n\t\t\tthis.socketEmit(\"ghostShapeMoved\", this._getStatePayload());\n\t\t}\n\t\tthis._draw();\n\t},\n\n\t// Update game data\n\t_update: function () {\n\t\tif (this.isMyTurn()) {\n\t\t\tif (this.shape.canDown(this.matrix)) {\n\n\t\t\t\tthis.shape.goDown(this.matrix);\n\t\t\t} else {\n\t\t\t\t// Trying to debug\n\t\t\t\t// This is needed because when a block lands, \n\t\t\t\t// We want to pause the game ASAP and disallow any more incoming keyboard inputs\n\t\t\t\tthis.pause();\n\t\t\t\tthis.shape.copyTo(this.matrix);\n\t\t\t\tif (consts.USE_GHOST_SHAPE) {\n\t\t\t\t\tvar ghostm = this.ghostShape.shapeLoc(this.matrix);\n\t\t\t\t\tvar activem = this.shape.shapeLoc(this.matrix);\n\t\t\t\t\tif (checkSame(activem, ghostm)) this.suggestionTaken += 1;\n\t\t\t\t}\n\n\t\t\t\tthis.roundEnd = new Date().getTime();\n\t\t\t\t\n\t\t\t\tthis.shapeList.push(this.shape.flag);\n\t\t\t\tvar addedShape = this.shape.flag;\n\n\t\t\t\tthis.timeList.push(this.roundEnd - this.roundStart);\n\t\t\t\tthis.roundStart = this.roundEnd;\n\n\t\t\t\t//update turnCount here!\n\t\t\t\tthis.turnCount +=1;  \n\n\t\t\t\t// update each players turn\n\t\t\t\tthis.playersTally[this.nextPlayerId].totalTurns +=1;\n\n\t\t\t\t//timeList gets updated two 2 when there is an update in reset count\n\t\t\t\tif (this.timeList.length ==2 ) {\n\t\t\t\t\tthis.timeList = this.timeList.slice(0,1);\n\t\t\t\t}\n\n\t\t\t\t// this.currentTurn \n\t\t\t\tthis._check();\n\t\t\t\tthis._fireShape();\n\t\t\t\tconsole.log(\"BEFORE EMIT\", this.randVar);\n\t\t\t\tthis.socketEmit(\"block_landed\", {\n\t\t\t\t\tgameId: this.gameId,\n\t\t\t\t\tplayerName: this.playerName,\n\t\t\t\t\tcurrentShape: addedShape,\n\t\t\t\t\tsuggestionTaken: this.suggestionTaken,\n\t\t\t\t\tcurrentTurn: this.currentTurn,\n\t\t\t\t\tnextPlayerId: this.nextPlayerId,\n\t\t\t\t\tplayCount: this.playCount,\n\t\t\t\t\tturnCount: this.turnCount,\n\t\t\t\t\tscore: this.score,\n\t\t\t\t\tresetCount: this.resetCount,\n\t\t\t\t\tplayersTally: this.playersTally,\n\t\t\t\t\tturnStart: this.turnStart,\n\t\t\t\t\tshapeList: this.shapeList,\n\t\t\t\t\tturnEnd: new Date().getTime(),\n\t\t\t\t\ttimeList: this.timeList,\n\t\t\t\t\tmatrix: this.matrix, \n\t\t\t\t\tmaxTurns: this.MAX_TURNS,\n\t\t\t\t\trandVar: this.randVar\n\n\t\t\t\t})\n\t\t\t\tviews.setTurnCount(this.turnCount);\n\t\t\t}\n\t\t\tif (this.isMyTurn()) {\n\t\t\t\tthis.socketEmit(\"state\", this._getStatePayload());\n\t\t\t}\n\t\t} \n\n\t\tthis._draw();\n\n\t\tlet endGame = checkGameOver(this.matrix);\n\t\tif (this.turnCount < this.MAX_TURNS) {\n\t\t\tif (this.isMyTurn() && endGame === true) {\n\t\t\t\tclearMatrix(this.matrix);\n\n\t\t\t\tthis.resetCount = this.resetCount + 1;\n\t\t\t\tthis.socketEmit(\"game_reset\", this._getStatePayload());\n\t\t\t}\n\t\t} else {\n\t\t\tendGame = true;\n\t\t\tthis.isGameOver = endGame;\n\t\t\tviews.setGameOver(this.isGameOver);\n\t\t}\n\n\t\tif (this.isGameOver) {\n\t\t\tviews.setFinalScore(this.score);\n\t\t}\n\t},\n\t// Check and update game data\n\t_check: function () {\n\t\tvar rows = checkFullRows(this.matrix);\n\t\tif (rows.length) {\n\t\t\tremoveRows(this.matrix, rows);\n\t\t\tvar score = calcScore(rows);\n\t\t\tvar reward = calcRewards(rows);\n\t\t\tthis.score += score + reward;\n\t\t\tthis.playersTally[this.socket.id].totalScore += (score + reward);\n\t\t\tthis.playersTally[this.socket.id].lastScore += (score + reward);\n\t\t\tviews.setReward(reward);\n\t\t}\n\t\t// score calculation including the row and soft drop and harddrop;\n\t\tthis.playersTally[this.socket.id].lastScore += this.individualScore;\n\t\tthis.individualScore  = 0;\n\t\tviews.setScore(this.score);\n\t},\n\n\t// Check and update game level\n\t// _checkLevel: function () {\n\t// \tvar currentTime = new Date().getTime();\n\t// \tif (currentTime - this.levelTime > consts.LEVEL_INTERVAL) {\n\t// \t\tthis.level += 1;\n\t// \t\tthis.interval = calcIntervalByLevel(this.level);\n\t// \t\tviews.setLevel(this.level);\n\t// \t\tthis.levelTime = currentTime;\n\t// \t}\n\t// }\n}\n\n\nwindow.Tetris = Tetris;\n\n//# sourceURL=webpack:///./public/src/main.js?");

/***/ }),

/***/ "./public/src/shapes.js":
/*!******************************!*\
  !*** ./public/src/shapes.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var consts = __webpack_require__(/*! ./consts.js */ \"./public/src/consts.js\");\nvar COLORS = consts.COLORS;\nvar COLUMN_COUNT = consts.COLUMN_COUNT;\n\n/**\n\tDefined all shapes used in Tetris game. \n\tYou can add more shapes if you wish.\n*/\nfunction ShapeL(color) {\n\tvar state1 = [\n\t\t[1, 0],\n\t\t[1, 0],\n\t\t[1, 1]\n\t];\n\n\tvar state2 = [\n\t\t[0, 0, 1],\n\t\t[1, 1, 1]\n\t];\n\n\tvar state3 = [\n\t\t[1, 1],\n\t\t[0, 1],\n\t\t[0, 1]\n\t];\n\n\tvar state4 = [\n\t\t[1, 1, 1],\n\t\t[1, 0, 0]\n\t];\n\n\n\tthis.states = [state1, state2, state3, state4];\n\tthis.x = 4;\n\tthis.y = -3;\n\tthis.flag = 'L';\n\tthis.color = COLORS[color];\n}\n\nfunction ShapeLR(color) {\n\tvar state1 = [\n\t\t[0, 1],\n\t\t[0, 1],\n\t\t[1, 1]\n\t];\n\n\tvar state2 = [\n\t\t[1, 1, 1],\n\t\t[0, 0, 1]\n\t];\n\n\tvar state3 = [\n\t\t[1, 1],\n\t\t[1, 0],\n\t\t[1, 0]\n\t];\n\n\tvar state4 = [\n\t\t[1, 0, 0],\n\t\t[1, 1, 1]\n\t];\n\n\n\tthis.states = [state1, state2, state3, state4];\n\tthis.x = 4;\n\tthis.y = -3;\n\tthis.flag = 'LR';\n\tthis.color = COLORS[color];\n}\n\nfunction ShapeO(color) {\n\n\tvar state1 = [\n\t\t[1, 1],\n\t\t[1, 1]\n\t];\n\n\n\tthis.states = [state1];\n\tthis.x = 4;\n\tthis.y = -2;\n\tthis.flag = 'O';\n\tthis.color = COLORS[color];\n}\n\nfunction ShapeI(color) {\n\tvar state1 = [\n\t\t[1],\n\t\t[1],\n\t\t[1],\n\t\t[1]\n\t];\n\n\tvar state2 = [\n\t\t[1, 1, 1, 1]\n\t];\n\n\tthis.states = [state1, state2];\n\n\tthis.x = 4;\n\tthis.y = -4;\n\tthis.flag = 'I';\n\tthis.color = COLORS[color];\n}\n\nfunction ShapeT(color) {\n\tvar state1 = [\n\t\t[1, 1, 1],\n\t\t[0, 1, 0]\n\t];\n\n\tvar state2 = [\n\t\t[1, 0],\n\t\t[1, 1],\n\t\t[1, 0]\n\t];\n\n\tvar state3 = [\n\t\t[0, 1, 0],\n\t\t[1, 1, 1]\n\t];\n\n\tvar state4 = [\n\t\t[0, 1],\n\t\t[1, 1],\n\t\t[0, 1]\n\t];\n\n\tthis.states = [state1, state2, state3, state4];\n\tthis.x = 3;\n\tthis.y = -2;\n\tthis.flag = 'T';\n\tthis.color = COLORS[color];\n}\n\nfunction ShapeZ(color) {\n\tvar state1 = [\n\t\t[1, 1, 0],\n\t\t[0, 1, 1]\n\t];\n\n\tvar state2 = [\n\t\t[0, 1],\n\t\t[1, 1],\n\t\t[1, 0]\n\t];\n\n\tthis.states = [state1, state2];\n\tthis.x = 3;\n\tthis.y = -2;\n\tthis.flag = 'Z';\n\tthis.color = COLORS[color];\n}\n\nfunction ShapeZR(color) {\n\tvar state1 = [\n\t\t[0, 1, 1],\n\t\t[1, 1, 0]\n\t];\n\n\tvar state2 = [\n\t\t[1, 0],\n\t\t[1, 1],\n\t\t[0, 1]\n\t];\n\n\tthis.states = [state1, state2];\n\tthis.x = 3;\n\tthis.y = -2;\n\tthis.flag = 'ZR';\n\tthis.color = COLORS[color];\n}\n// Default shape object to copy the shape from backend; \nfunction ShapeDefault(payload) {\n\n}\n\n/**\nIs shape can move\n@param shape: tetris shape\n@param matrix: game matrix\n@param action:  'left','right','down','rotate'\n*/\nvar isShapeCanMove = function (shape, matrix, action) {\n\tvar rows = matrix.length;\n\tvar cols = matrix[0].length;\n\n\tvar isBoxCanMove = function (box) {\n\n\t\tvar x = shape.x + box.x;\n\t\tvar y = shape.y + box.y;\n\t\tif (y < 0) {\n\t\t\treturn true;\n\t\t}\n\t\tif (action === 'left') {\n\t\t\tx -= 1;\n\t\t\treturn x >= 0 && x < cols && matrix[y][x] == 0;\n\t\t} else if (action === 'right') {\n\t\t\tx += 1;\n\t\t\treturn x >= 0 && x < cols && matrix[y][x] == 0;\n\t\t} else if (action === 'down') {\n\t\t\ty += 1;\n\t\t\treturn y < rows && matrix[y][x] == 0;\n\t\t} else if (action === 'rotate') {\n\t\t\treturn y < rows && !matrix[y][x];\n\t\t}\n\t};\n\n\tvar boxes = action === 'rotate' ? shape.getBoxes(shape.nextState()) : shape.getBoxes(shape.state);\n\n\n\tfor (var i in boxes) {\n\t\tif (!isBoxCanMove(boxes[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n};\n\n/**\n All shapes shares the same method, use prototype for memory optimized\n*/\n\nShapeL.prototype =\n\tShapeLR.prototype =\n\tShapeO.prototype =\n\tShapeI.prototype =\n\tShapeT.prototype =\n\tShapeZ.prototype =\n\tShapeZR.prototype =\n\tShapeDefault.prototype = {\n\n\t\tinit: function () {\n\t\t\tthis.state = 0;\n\t\t\tthis.allBoxes = {};\n\t\t\tthis.y = 0;\n\t\t},\n\t\t//set the instance variable of the function\n\t\tupdateShape: function (payload) {\n\t\t\tthis.states = payload.states;\n\t\t\tthis.state = payload.state;\n\t\t\tthis.flag = payload.flag;\n\t\t\tthis.x = payload.x;\n\t\t\tthis.y = payload.y;\n\t\t\tthis.color = payload.color;\n\t\t\tthis.allBoxes = payload.allBoxes;\n\t\t},\n\n\t\t// Get boxes matrix which composite the shape\n\t\tgetBoxes: function (state) {\n\t\t\tvar boxes = this.allBoxes[state] || [];\n\n\t\t\tif (boxes.length) {\n\t\t\t\treturn boxes;\n\t\t\t}\n\t\t\tvar matrix = this.matrix(state);\n\n\t\t\tfor (var i = 0; i < matrix.length; i++) {\n\t\t\t\tvar row = matrix[i];\n\t\t\t\tfor (var j = 0; j < row.length; j++) {\n\t\t\t\t\tif (row[j] === 1) {\n\t\t\t\t\t\tboxes.push({\n\t\t\t\t\t\t\tx: j,\n\t\t\t\t\t\t\ty: i\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.allBoxes[state] = boxes;\n\t\t\treturn boxes;\n\t\t},\n\t\t//Get matrix for specified state\n\t\tmatrix: function (state) {\n\t\t\n\t\t\tvar st = state !== undefined ? state : this.state;\n\t\t\treturn this.states[st];\n\t\t},\n\t\t//Rotate shape\n\t\trotate: function (matrix) {\n\t\t\tif (isShapeCanMove(this, matrix, 'rotate')) {\n\t\t\t\tthis.state = this.nextState();\n\t\t\t\t//fix position if shape is out of right border\n\t\t\t\tvar right = this.getRight();\n\t\t\t\tif (right >= COLUMN_COUNT) {\n\t\t\t\t\tthis.x -= right - COLUMN_COUNT + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t//Caculate the max column of the shape\n\t\tgetColumnCount: function () {\n\t\t\tvar mtx = this.matrix();\n\t\t\tvar colCount = 0;\n\t\t\tfor (var i = 0; i < mtx.length; i++) {\n\t\t\t\tcolCount = Math.max(colCount, mtx[i].length);\n\t\t\t}\n\t\t\treturn colCount;\n\t\t},\n\t\t//Caculate the max row of the shape\n\t\tgetRowCount: function () {\n\t\t\treturn this.matrix().length;\n\t\t},\n\t\t//Get the right pos of the shape\n\t\tgetRight: function () {\n\t\t\tvar boxes = this.getBoxes(this.state);\n\t\t\tvar right = 0;\n\n\t\t\tfor (var i in boxes) {\n\t\t\t\tright = Math.max(boxes[i].x, right);\n\t\t\t}\n\t\t\treturn this.x + right;\n\t\t},\n\t\t//Return the next state of the shape\n\t\tnextState: function () {\n\t\t\treturn (this.state + 1) % this.states.length;\n\t\t},\n\t\t//Check if the shape can move down\n\t\tcanDown: function (matrix) {\n\t\t\treturn isShapeCanMove(this, matrix, 'down');\n\t\t},\n\t\t//Check if the shape can move left\n\t\tcanLeft: function (matrix) {\n\t\t\treturn isShapeCanMove(this, matrix, 'left');\n\t\t},\n\t\t//Check if the shape can move right\n\t\tcanRight: function (matrix) {\n\t\t\treturn isShapeCanMove(this, matrix, 'right');\n\t\t},\n\t\t//Move the shape down \n\t\tgoDown: function (matrix) {\n\t\t\tif (isShapeCanMove(this, matrix, 'down')) {\n\t\t\t\tthis.y += 1;\n\t\t\t}\n\t\t},\n\t\t//Move the shape down \n\t\tgoDownBut: function (matrix) {\n\t\t\tif (isShapeCanMove(this, matrix, 'down')) {\n\t\t\t\tthis.y += 1;\n\t\t\t}\n\t\t},\n\t\t//Move the shape to the Bottommost\n\t\tgoBottom: function (matrix) {\n\t\t\tx = 0;\n\t\t\tif (isShapeCanMove(this, matrix, 'down')) {\n\t\t\t\twhile (isShapeCanMove(this, matrix, 'down')) {\n\t\t\t\t\tthis.y += 1;\n\t\t\t\t\tx += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn x;\n\t\t},\n\t\t//Move the shape to the left\n\t\tgoLeft: function (matrix) {\n\t\t\tif (isShapeCanMove(this, matrix, 'left')) {\n\t\t\t\tthis.x -= 1;\n\t\t\t}\n\t\t},\n\t\t//Move the shape to the right\n\t\tgoRight: function (matrix) {\n\t\t\tif (isShapeCanMove(this, matrix, 'right')) {\n\t\t\t\tthis.x += 1;\n\t\t\t}\n\t\t},\n\t\t//Find the location of piece and return a location list\n\t\tshapeLoc: function(matrix) {\n\t\t\t\tvar smatrix = this.matrix(); \n\t\t\t\tvar list = []; \n\t\t\t\tfor (var i = 0; i < smatrix.length; i++) {\n\t\t\t\tvar row = smatrix[i];\n\t\t\t\tfor (var j = 0; j < row.length; j++) {\n\t\t\t\t\tif (row[j] === 1) {\n\t\t\t\t\t\tvar x = this.x + j;\n\t\t\t\t\t\tvar y = this.y + i;\n\t\t\t\t\t\tlist.push(x);\n\t\t\t\t\t\tlist.push(y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn list;\n\t\t},\n\t\t//Copy the shape data to the game data\n\t\tcopyTo: function (matrix) {\n\t\t\tvar smatrix = this.matrix();\n\t\t\tfor (var i = 0; i < smatrix.length; i++) {\n\t\t\t\tvar row = smatrix[i];\n\t\t\t\tfor (var j = 0; j < row.length; j++) {\n\t\t\t\t\tif (row[j] === 1) {\n\t\t\t\t\t\tvar x = this.x + j;\n\t\t\t\t\t\tvar y = this.y + i;\n\t\t\t\t\t\tif (x >= 0 && x < matrix[0].length && y >= 0 && y < matrix.length) {\n\t\t\t\t\t\t\tmatrix[y][x] = this.color;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n/**\n\tCreate  a random shape for game\n*/\nfunction generateShape(payload) {\n\tif (payload) {\n\t\tshape = new ShapeDefault(payload);\n\t\tshape.init();\n\t\tshape.updateShape(payload);\n\t} else {\n\t\tvar result = Math.floor(Math.random() * 7);\n\t\tswitch (result) {\n\t\t\tcase 0:\n\t\t\t\tshape = new ShapeL(0);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tshape = new ShapeO(1);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tshape = new ShapeZ(2);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tshape = new ShapeT(3);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tshape = new ShapeLR(4);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tshape = new ShapeZR(5);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tshape = new ShapeI(6);\n\t\t\t\tbreak;\n\t\t}\n\t\tshape.init();\n\t}\n\treturn shape;\n}\n\nmodule.exports.generateShape = generateShape;\n\n\n/*\nShape: {\n\tcolor:    //int\n\n}\n*/\n\n//# sourceURL=webpack:///./public/src/shapes.js?");

/***/ }),

/***/ "./public/src/socket.js":
/*!******************************!*\
  !*** ./public/src/socket.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const startSocket = function () {\n\n}\n\nmodule.exports = {\n  startSocket: startSocket\n}\n\n//# sourceURL=webpack:///./public/src/socket.js?");

/***/ }),

/***/ "./public/src/utils.js":
/*!*****************************!*\
  !*** ./public/src/utils.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nvar exports = module.exports = {};\n\nvar $ = function (id) {\n    return document.getElementById(id);\n};\n\n\n\n//if object is plain object\nvar _isPlainObject = function (obj) {\n\n    if (typeof obj !== 'object') {\n        return false;\n    }\n\n    if (obj.constructor &&\n        !hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf')) {\n        return false;\n    }\n\n    // If the function hasn't returned already, we're confident that\n    // |obj| is a plain object, created by {} or constructed with new Object\n    return true;\n};\n\n// this method source code is from jquery 2.0.x\n// merge object's value and return\nvar extend = function () {\n    var src, copyIsArray, copy, name, options, clone,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = true;\n\n    // Handle a deep copy situation\n    if (typeof target === 'boolean') {\n        deep = target;\n        // skip the boolean and the target\n        target = arguments[i] || {};\n        i++;\n    }\n\n    // Handle case when target is a string or something (possible in deep copy)\n    if (typeof target !== 'object' && typeof obj !== 'function') {\n        target = {};\n    }\n\n\n    if (i === length) {\n        target = this;\n        i--;\n    }\n\n    for (; i < length; i++) {\n        // Only deal with non-null/undefined values\n        if ((options = arguments[i]) != null) {\n            // Extend the base object\n            for (name in options) {\n                src = target[name];\n                copy = options[name];\n\n                // Prevent never-ending loop\n                if (target === copy) {\n                    continue;\n                }\n                // Recurse if we're merging plain objects or arrays\n                if (deep && copy && (_isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {\n                    if (copyIsArray) {\n                        copyIsArray = false;\n                        clone = src && Array.isArray(src) ? src : [];\n\n                    } else {\n                        clone = src && _isPlainObject(src) ? src : {};\n                    }\n\n                    // Never move original objects, clone them\n                    //console.log('abc');\n\n                    target[name] = extend(deep, clone, copy);\n\n                    // Don't bring in undefined values\n                } else if (copy !== undefined) {\n                    target[name] = copy;\n                }\n            }\n        }\n    }\n\n    // Return the modified object\n    return target;\n};\n\n\nvar proxy = function (fn, context) {\n    var args = [].slice.call(arguments, 2);\n    proxy = function () {\n        return fn.apply(context || this, args.concat([].slice.call(arguments)));\n    };\n    return proxy;\n};\n\nvar aniFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||\n    window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\nwindow.requestAnimationFrame = aniFrame;\n\n\nexports.$ = $;\nexports.extend = extend;\nexports.proxy = proxy;\n\n\n//# sourceURL=webpack:///./public/src/utils.js?");

/***/ }),

/***/ "./public/src/views.js":
/*!*****************************!*\
  !*** ./public/src/views.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n All dom definitions and actions\n*/\nvar utils = __webpack_require__(/*! ./utils.js */ \"./public/src/utils.js\");\nvar consts = __webpack_require__(/*! ./consts.js */ \"./public/src/consts.js\");\n\nvar $ = utils.$;\n\n//doms\nvar scene = $('scene');\nvar side = $('side');\nvar info = $('info');\nvar preview = $('preview');\nvar level = $('level');\nvar score = $('score');\nvar rewardInfo = $('rewardInfo');\nvar reward = $('reward');\nvar gameOver = $('gameOver');\nvar quitGame = $('quitGame');\nvar survey = $('survey');\nvar finalScore = $('finalScore');\nvar quitFinalScore = $('quitFinalScore');\nvar notification = $('notification');\nvar imageNotification = $('imageNotification');\nvar player = $('player');\nvar leftName = $('leftName');\nvar distributer = $('distributer');\nvar quitGamePlayer = $('quitGamePlayer'); \nvar partnerQuitPlayer = $('partnerQuitPlayer');\nvar gameOverPlayer = $('gameOverPlayer');\nvar partnerOverPlayer = $('partnerOverPlayer');\nvar turn = $('turn');\nvar modal = $(\"modal\");\nvar tetris = $(\"tetris\");\nvar message = $(\"message\");\nvar endPairMessage = $('endPairMessage');\nvar DupPlayerMessage = $('DupPlayerMessage'); \nvar AIPairingMessage = $('AIPairingMessage');\nvar AIPairingImage = $('AIPairingImage');\nvar playCount = $(\"play-count\");\nvar turnCount = $(\"turn-count\");\nvar error = $(\"error\");\n// quit button.\nvar quitButton = $(\"quitButton\");\nvar leftStatusBar = $(\"leftStatusBar\");\nvar qualtlink = $(\"qualtlink\");\n\n//defaults\nvar SIDE_WIDTH = consts.SIDE_WIDTH;\n\n\n/**\n\tCaculate the game container size\n*/\nvar getContainerSize = function (maxW, maxH) {\n\tvar dw = document.documentElement.clientWidth;\n\tvar dh = document.documentElement.clientHeight;\n\tvar size = {};\n\tif (dw > dh) {\n\t\tsize.height = Math.min(maxH, dh);\n\t\tsize.width = Math.min((size.height / 2) + SIDE_WIDTH, maxW);\n\t} else {\n\t\tsize.width = Math.min(maxW, dw);\n\t\tsize.height = Math.min(maxH, dh);\n\t}\n\treturn size;\n\n};\n\n\n/**\n\tLayout game elements\n*/\nvar layoutView = function (container, maxW, maxH) {\n\t// Code without left Status Bar \n\tvar size = getContainerSize(maxW, maxH);\n\tvar st = container.style;\n\tst.height = size.height + 'px';\n\tst.width = size.width + 'px';\n\tst.marginTop = (-(size.height / 2)) + 'px';\n\tst.marginLeft = (-(size.width / 2)) + 'px';\n\n\t//layout scene\n\tscene.height = size.height;\n\tscene.width = (size.height / 2);\n\tvar sideW = size.width - scene.width;\n\tside.style.width = sideW + 'px';\n\n\tif (sideW < SIDE_WIDTH) {\n\t\tinfo.style.width = side.style.width;\n\t}\n\tpreview.width = 80;\n\tpreview.height = 80;\n\n\tgameOver.style.width = scene.width + 'px';\n\n\n\t/* Code with left Status Bar \n\tvar leftStatusBarWidth = 150; \n\tleftStatusBar.style.width = leftStatusBarWidth + \"px\";\n\n\tvar size = getContainerSize(maxW, maxH);\n\tvar st = container.style;\n\tst.height = size.height + 'px';\n\tst.width = size.width + leftStatusBarWidth + 'px'; \n\tst.marginTop = (-(size.height / 2)) + 'px';\n\tst.marginLeft = (-(size.width / 2)) + 'px';\n\n\t//layout scene\n\tscene.height = size.height;\n\tscene.width = (size.height / 2);\n\tscene.style.left = leftStatusBarWidth + \"px\"; \n\n\tvar sideW = size.width - scene.width;\n\tside.style.width = sideW + 'px';\n\n\tif (sideW < SIDE_WIDTH) {\n\t\tinfo.style.width = side.style.width;\n\t}\n\tpreview.width = 80;\n\tpreview.height = 80;\n\n\tgameOver.style.width = scene.width + 'px';\n\tgameOver.style.left = leftStatusBarWidth+ 'px';\n\n\tquitGame.style.width = scene.width + 'px';\n\tquitGame.style.left = leftStatusBarWidth + 'px'; */\n\n\n}\n\n\n/**\n\tMain tetris game view\n*/\nvar tetrisView = {\n\n\tinit: function (id, maxW, maxH) {\n\t\tthis.container = $(id);\n\t\tthis.scene = scene;\n\t\tthis.preview = preview;\n\t\t//this.btnRestart = btnRestart;\n\t\tlayoutView(this.container, maxW, maxH);\n\t\tthis.scene.focus();\n\n\t\trewardInfo.addEventListener('animationEnd', function (e) {\n\t\t\trewardInfo.className = 'invisible';\n\t\t});\n\t},\n\t// Update the score \n\tsetScore: function (scoreNumber) {\n\t\tconsole.log(\"setScore\", scoreNumber);\n\t\tscore.innerHTML = scoreNumber;\n\t\tscore.style.fontFamily = 'Lucida Sans Unicode', 'Lucida Grande';\n\t},\n\t// Update the finnal score\n\tsetFinalScore: function (scoreNumber) {\n\t\tconsole.log(\"set final score\");\n\t\tfinalScore.innerHTML = scoreNumber;\n\t},\n\n\tsetQuitFinalScore: function(scoreNumber) {\n\t\tquitFinalScore.innerHTML = scoreNumber;\n\t},\n\t// Update the level\n\tsetLevel: function (levelNumber) {\n\t\tlevel.innerHTML = levelNumber;\n\t},\n\t// Update the extra reward score\n\tsetReward: function (rewardScore) {\n\t\tif (rewardScore > 0) {\n\t\t\treward.innerHTML = rewardScore;\n\t\t\trewardInfo.className = 'fadeOutUp animated';\n\t\t} else {\n\t\t\trewardInfo.className = 'invisible';\n\t\t}\n\t},\n\t// Set game over view\n\tsetGameOver: function (isGameOver) {\n\t\tconsole.log(\"set game over\", isGameOver);\n\t\tsurvey.style.display = isGameOver ? 'block' : 'none';\n\t\tif (isGameOver == true) {\n\t\t\ttetris.style.display = 'none';\n\t\t}\n\t},\n\n\tsetQuitGame: function(isGameOver) {\n\t\tsurvey.style.display = isGameOver ? 'block': 'none';\n\t\tif (isGameOver == true) {\n\t\t\ttetris.style.display = 'none';\n\t\t}\n\t}, \n\n\tsetPlayer: function (playerName) {\n\t\tplayer.innerHTML = playerName;\n\t\tplayer.style.fontFamily = 'Lucida Sans Unicode', 'Lucida Grande';\n\t\tplayer.style.display = 'none';\n\t\tleftName.style.display = 'none';\n\t},\n\n\tsetDistributer: function(dist) {\n\t\tdistType = \"\";\n\t\tif (dist ==0 ) {\n\t\t\tdistType = \"Aritificial Intelligence\"; \n\t\t} else {\n\t\t\tdistType = \"MTurk Worker\";\n\t\t}\n\t\tdistributer.innerHTML = distType;\n\t\tdistributer.style.fontFamily = 'Lucida Sans Unicode', 'Lucida Grande';\n\t},\n\n\tsetQuitGamePlayer: function (playerName, partnerName) {\n\t\tquitGamePlayer.innerHTML = playerName;\n\t\tpartnerQuitPlayer.innerHTML = partnerName; \n\t\tplayer.style.fontFamily = 'Lucida Sans Unicode', 'Lucida Grande';\n\t},\n\n\tsetGameOverPlayer: function (playerName, partnerName) {\n\t\tgameOverPlayer.innerHTML = playerName;\n\t\tpartnerOverPlayer.innerHTML = partnerName; \n\t\tplayer.style.fontFamily = 'Lucida Sans Unicode', 'Lucida Grande';\n\t},\n\t\n\tsetTurn: function (playerName,currentTurn) {\n\n\t\tif (playerName == 0 && currentTurn == 0){\n\t\t\tconsole.log('DistributerTurn  EOIHOAJ')\n\t\t\tturn.innerHTML = 'Distributer';\n\t\t}\n\n\t\telse if (playerName  == currentTurn){\n\t\t\tturn.innerHTML = 'Your Turn';\n\n\t\t}else {\n\t\t\tturn.innerHTML = \"Other Player\";\n\t\t}\n\t\tturn.style.fontFamily = 'Lucida Sans Unicode', 'Lucida Grande';\n\t\tturn.style.color = '#40bfc1';\n\t},\n\tsetQualtLink: function (playerName,partnerName,is_AI,distribution) {\n\t\tdistribution_var = '';\n\t\tif (distribution == 0){\n\t\t\tdistribution_var = \"50/50\";\n\t\t} else{\n\t\t\tdistribution_var = \"90/10\";\n\t\t}\n\n\n\t\tdist_new='';\n\n\t\tif (is_AI == 0){\n\t\t\tdist_new= \"AI\";\n\n\t\t} else {\n\t\t\tdist_new = \"Human\";\n\t\t}\n\t\tdocument.getElementById('qualtlink').src = \"https://cornell.ca1.qualtrics.com/jfe/form/SV_6sOpOUOZAlKigaW\" + \"?PlayerID=\" + playerName + \"+?PartnerID=\"+ partnerName +\"+?Distributer=\"+ dist_new+\"+?Distribution=\"+distribution_var;\n\t\tconsole.log(document.getElementById('qualtlink').src );\n\t},\n\n\n\tsetPlayCount: function (count) {\n\t\tplayCount.innerHTML = count;\n\t\tplayCount.style.fontFamily = 'Lucida Sans Unicode', 'Lucida Grande';\n\t},\n\tsetTurnCount: function (count) {\n\t\tturnCount.innerHTML = count;\n\t\tturnCount.style.fontFamily = 'Lucida Sans Unicode', 'Lucida Grande';\n\t},\n\tsetPairingMessage: function (value) {\n\t\tlet x = value ? 1 : 0;\n\t\tmessage.style.opacity = x;\n\t\tmessage.style.top = \"50%\";\n\t\tmessage.style.left = \"50%\";\n\t},\n\n\tsetDupPlayerMessage: function(value) {\n\t\t// set Dup Player Message \n\t\tlet x = value ? 1 : 0; \n\t\tif (value) {\n\t\t\tDupPlayerMessage.innerHTML = 'You can only play the game once.\\\n\t\t\tPlease contact us if there are any questions'\n\t\t\tDupPlayerMessage.style.opacity = x\n\t\t}\n\t},\n\n\tsetEndPairingMessage: function(value) {\n\t\tlet x = value ? 1 : 0;\n\t\tendPairMessage.style.opacity = x; \n\t\tendPairMessage.style.top = \"50%\"; \n\t\tendPairMessage.style.left = \"50%\";\n\t},\n\t\n\tsetNotification: function (text) {\n\t\tnotification.innerHTML = text;\n\t\tnotification.style.opacity = 1;\n\t\tsetTimeout(function () {\n\t\t\tdocument.getElementById(\"notification\").style.opacity = 0;\n\t\t}, consts.WAIT_TIME * 2000);\n\t},\n/*\n\tsetNotification: function (number,Ai_Human) {\n\t\t//notification.innerHTML = text;\n\t\t//Ai_Human == 0 => Ai\n\t\t//Ai_Human == 1 => Human\n\n\t\t//number == 1 =>your turn\n\t\t//number ==0 => partner's turn\n\t\tif(Ai_Human == 0){\n\n\t\t\tif (number ==0){\n\t\t\timageNotification.innerHTML = \"<img src=\\\"../images/AI_PartnerTurn.png\\\" id=\\\"imageNotification\\\">\";\n\t\t} else {\n\t\t\timageNotification.innerHTML = \"<img src=\\\"../images/Ai_YourTurn.png\\\" id=\\\"imageNotification\\\">\";\n\n\t\t}\n\n\n\t\t} else{\n\t\t\tif (number ==0){\n\t\t\timageNotification.innerHTML = \"<img src=\\\"../images/Human_PartnerTurn.png\\\" id=\\\"imageNotification\\\">\";\n\t\t} else {\n\t\t\timageNotification.innerHTML = \"<img src=\\\"../images/Human_YourTurn.png\\\" id=\\\"imageNotification\\\">\";\n\n\n\t\t}\n\t}\n\t\t\n\t\timageNotification.style.opacity = 1\n\t\tsetTimeout(function () {\n\t\t\tconsole.log(\"entering set\")\n\t\t\tvar imageId = document.getElementById(\"imageNotification\").style.opacity = 0\n\t\t}, consts.WAIT_TIME * 1500);\n\t}, */\n\n\tsetDecideNotification: function (text) {\n\t\tnotification.innerHTML = text; \n\t\tnotification.style.opacity = 1;\n\t\tsetTimeout(function () {\n\t\t\tdocument.getElementById(\"notification\").style.opacity = 0;\n\t\t}, consts.WAIT_TIME * 2000);\n\t},\n\n\tsetAIPairingImage: function(is_AI) {\n\t\tif (is_AI ==0){\n\t\t\tAIPairingMessage.innerHTML = '<font size = \"5\"> <u> The Distributer is a(n) Artificial Intelligence... Please Wait for Game to Start </u> </font>'\n\t\t\tAIPairingImage.innerHTML = \"<img src=\\\"../images/AI_Distributer.png\\\" id=\\\"AIPairingImage\\\">\"\n\t\t} else {\n\t\t\tAIPairingMessage.innerHTML = '<font size = \"5\"> <u> The Distributer is a(n) MTurk Worker... Please Wait for Game to Start </u> </font>'\n\t\t\tAIPairingImage.innerHTML = \"<img src=\\\"../images/MTurkWorker_Distributer.png\\\" id=\\\"AIPairingImage\\\">\"\n\t\t}\n\n\t\tAIPairingImage.style.opacity = 1 \n\t},\n\t\n\tsetImageNotification: function(is_AI) {\n\t\t// logic to check whether the ai or human decision-maker is randomly assigned\n\t\tif (is_AI ==1){\n\n\t\t\timageNotification.innerHTML = \"<img src=\\\"../images/human_decisionmaking.png\\\" id=\\\"imageNotification\\\">\";\n\t\t} else {\n\t\t \timageNotification.innerHTML = \"<img src=\\\"../images/ai_decisionmaking.png\\\" id=\\\"imageNotification\\\">\";\n\t\t}\n\n\t\timageNotification.style.opacity = 1\n\t\tsetTimeout(function () {\n\t\t\tconsole.log(\"entering set\")\n\t\t\tvar imageId = document.getElementById(\"imageNotification\").style.opacity = 0\n\t\t}, consts.WAIT_TIME * 2000);\n\t},\n\n\thideModal: function () {\n\t\tmodal.style.display = \"none\";\n\t},\n\tshowTetris: function(){\n\t\ttetris.style.display = \"flex\";\n\t\t//setTimeout(function () => {console.log(\"hello\")}, 1000);\n\t},\n\n\tactivateQuitButton: function(){\n\t\tconsole.log(\"enter activate quitButton\");\n    \tquitButton.style.display = \"none\";\n    \tfunction displayBtn() {\n    \t\tquitButton.style.display = \"inline\";\n\t\t}\n\t\t// time used for developement purposes\n\t\t//setTimeout(displayBtn, 2000);\n\t\t// actual time used for production purposes 7 minutes\n\t\tsetTimeout(displayBtn, 0); //420000\n\t}\n};\n\nmodule.exports = tetrisView;\n\n//# sourceURL=webpack:///./public/src/views.js?");

/***/ })

/******/ });